import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.IntBinaryOperator;

import static java.lang.IO.println;
import static java.lang.System.nanoTime;
import static java.util.Arrays.copyOf;
import static java.util.Arrays.sort;
import static java.util.Comparator.comparingLong;
import static util.Print.printf;

public class _389_FindTheDifference {
    
    /*
    389. Find the Difference
    You are given two strings s and t.
    
    String t is generated by random shuffling string s and then adds one more
    letter at a random position.
    
    Return the letter that was added to t.
   
    Example 1:
    Input: s = "abcd", t = "abcde"
    Output: "e"
    Explanation: 'e' is the letter that was added.
    
    Example 2:
    Input: s = "", t = "y"
    Output: "y"
    
    Constraints:
    0 <= s.length <= 1000
    t.length == s.length + 1
    s and t consist of lowercase English letters.
     */

    public static void main(String[] args) {
//        testFindTheDifference("abcd", "abcde");
//        testFindTheDifference("", "y");
//        testFindTheDifference("a", "aa");
//        testFindTheDifference("ae", "aea");
//        testFindTheDifference("ae", "eaa");

//        testFindTheDifferenceTrace("abcd", "abcde");
//        testFindTheDifferenceTrace("", "y");
//        testFindTheDifferenceTrace("a", "aa");
//        testFindTheDifferenceTrace("ae", "aea");
//        testFindTheDifferenceTrace("ae", "eaa");

        benchmarkAllRuntimes();
    }

    /*

   A função usa um vetor fixo de 26 inteiros (letters) para contar ocorrências por letra ‘a’......‘z’.
   A escolha de 26 posições é válida porque o problema restringe s e t a letras minúsculas inglesas.

   Passo a passo:
   1) Inicializa letters com zeros.
   2) Percorre s e faz contagem: para cada caractere c de s, incrementa letters[c - 'a'].
   3) Percorre t e “desconta”: para cada caractere c de t, decrementa letters[c - 'a'].
   4) Ao final, procura a primeira posição com valor negativo; essa posição indica a letra “extra”
      presente em t (porque todas as letras de s se anulam com t, e apenas a letra adicionada
      fica com contagem −1). Retorna (char) (i + 'a').

   Porque funciona:
   • Invariantes de contagem: toda letra que aparece k vezes em s e k vezes em t zera no somatório
     (k - k = 0). A única diferença é a letra adicionada em t, que resulta em −1 após o passo (3).
   • Ex.: s="ae", t="eaa" → após contar s: {a:1, e:1}; ao subtrair t: e→0, a→0, a→-1 → resposta='a'.

   Complexidade:
   • Tempo O(n), onde n = |s| + |t| (dois laços lineares).
   • Espaço O(1), pois o tamanho do vetor é constante (26), independente do tamanho das “Strings”.

   Observação didática:
   • Existe também a solução por XOR: fazer o XOR de todos os chars de s e de t.
     Como x^x=0 e 0^y=y, tudo cancela e sobra exatamente a letra extra. Também é O(n) e O(1).

*/
    public static char findTheDifference(String s, String t) {

        int[] letters = new int[26];

        for (int i = 0; i < s.length(); i++)
            letters[s.charAt(i) - 'a']++;

        for (int i = 0; i < t.length(); i++)
            letters[t.charAt(i) - 'a']--;

        for (int i = 0; i < letters.length; i++) {
            if (letters[i] < 0)
                return (char) (i + 'a');
        }

        return ' ';
    }

    public static char findTheDifferenceXor(String s, String t) {
        int x = 0;
        for (int i = 0; i < s.length(); i++) x ^= s.charAt(i);
        for (int i = 0; i < t.length(); i++) x ^= t.charAt(i);
        return (char) x;
    }

    public static char findTheDifferenceMap(String s, String t) {
        Map<Character, Integer> freq = new HashMap<>();

        // conta s
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            freq.put(c, freq.getOrDefault(c, 0) + 1);
        }

        // subtrai t; se passar de zero e ficar negativo, achamos a extra
        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            int newCount = freq.getOrDefault(c, 0) - 1;
            if (newCount < 0) return c;        // letra extra
            if (newCount == 0) freq.remove(c); // limpeza opcional
            else freq.put(c, newCount);
        }

        return ' '; // não deveria acontecer para entradas válidas
    }

    public static char findTheDifferenceSort(String s, String t) {
        char[] a = s.toCharArray();
        char[] b = t.toCharArray();
        sort(a);
        sort(b);
        for (int i = 0; i < a.length; i++) {
            if (a[i] != b[i]) return b[i];
        }
        return b[b.length - 1];
    }

    public static char findTheDifferenceSum(String s, String t) {
        int sum = 0;
        for (int i = 0; i < t.length(); i++) sum += t.charAt(i);
        for (int i = 0; i < s.length(); i++) sum -= s.charAt(i);
        return (char) sum;
    }

    public static char findTheDifferenceTrace(String s, String t) {
        println("\n[TRACE] s=\"" + s + "\", t=\"" + t + "\"");
        int[] letters = new int[26];

        println("[TRACE] Início: letters[26] = todos 0");

        println("[TRACE] Contando caracteres de s:");
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int idx = c - 'a';
            int antes = letters[idx];
            letters[idx]++;
            println(String.format("  i=%d, c='%c' -> letters[%d]: %d -> %d",
                    i, c, idx, antes, letters[idx]));
        }

        println("[TRACE] Subtraindo caracteres de t:");
        for (int j = 0; j < t.length(); j++) {
            char c = t.charAt(j);
            int idx = c - 'a';
            int antes = letters[idx];
            letters[idx]--;
            println(String.format("  j=%d, c='%c' -> letters[%d]: %d -> %d",
                    j, c, idx, antes, letters[idx]));
        }

        println("[TRACE] Varredura final (procura valor negativo):");
        for (int k = 0; k < 26; k++) {
            if (letters[k] < 0) {
                char added = (char) (k + 'a');
                println(String.format("  letters[%d]=%d < 0 -> caractere extra='%c'",
                        k, letters[k], added));
                return added;
            }
        }

        println("[TRACE] Nenhum valor negativo encontrado (entrada inválida).");
        return ' ';
    }

    public static void testFindTheDifferenceTrace(String s, String t) {
        println("\n==== TESTE DE MESA ====");
        println("Caso: s=\"" + s + "\", t=\"" + t + "\"");

        long start = nanoTime();
        char result = findTheDifferenceTrace(s, t);
        long end = nanoTime();

        println("[TRACE] Resultado final: " + result);
        println("[TRACE] Tempo: " + (end - start) + " ns");
        printf("[TRACE] Tempo: %.5f ms\n", (end - start) / 1_000_000.0);
    }

    public static void testFindTheDifference(String s, String t) {
        println("\nInput:  " + s + ", " + t);

        long start = nanoTime();
        char result = findTheDifference(s, t);
        long end = nanoTime();

        println("Output: " + result);
        println("Time: " + (end - start) + " ns");
        printf("Time: %.5f ms\n", (end - start) / 1_000_000.0);
    }

    @FunctionalInterface
    interface CharFinder {
        char apply(String s, String t);
    }

    record Impl(String name, CharFinder fn) {
    }

    // Evita DCE: se o resultado não for usado, o JIT pode "sumir" com trabalho
    private static final AtomicInteger BLACK_HOLE = new AtomicInteger(0);

    // reuso de um operador XOR sem capturar lambda a cada iteração
    private static final IntBinaryOperator XOR_OP = (a, b) -> a ^ b;

    private static void blackHole(char z) {
        BLACK_HOLE.getAndAccumulate(z, XOR_OP); // aplica prev ^ z de forma atômica (RMW atômico)

    }

    public static void benchmarkAllRuntimes() {
        Impl[] impls = {
                new Impl("array[26]", _389_FindTheDifference::findTheDifference),
                new Impl("xor", _389_FindTheDifference::findTheDifferenceXor),
                new Impl("sum", _389_FindTheDifference::findTheDifferenceSum),
                new Impl("sort", _389_FindTheDifference::findTheDifferenceSort),
                new Impl("map", _389_FindTheDifference::findTheDifferenceMap)
        };

        // Tamanhos dentro das restrições do problema
        int[] sizes = {0, 1, 5, 10, 50, 100, 300, 1000};
        final int casesPerSize = 64;     // total de casos ≈ sizes.length * casesPerSize
        final int warmupRounds = 3;      // rounds de aquecimento (não medidos)
        final int measureRounds = 7;     // rounds medidos (usaremos a mediana)
        final long seed = 42L;

        // Gera todos os casos previamente (evita custo de alocação durante a medição)
        List<String[]> cases = new ArrayList<>();
        Random rnd = new Random(seed);
        for (int n : sizes) {
            for (int k = 0; k < casesPerSize; k++) {
                cases.add(makeCase(rnd, n));
            }
        }
        final int opsPerRound = cases.size();

        Map<String, long[]> implTimes = new LinkedHashMap<>();

        for (Impl impl : impls) {
            for (int r = 0; r < warmupRounds; r++) {
                for (String[] c : cases) {
                    char z = impl.fn.apply(c[0], c[1]);
                    blackHole(z);
                }
            }

            long[] rounds = new long[measureRounds];
            for (int r = 0; r < measureRounds; r++) {
                long start = nanoTime();
                for (String[] c : cases) {
                    char z = impl.fn.apply(c[0], c[1]);
                    blackHole(z);
                }
                long end = nanoTime();
                rounds[r] = end - start;
            }
            implTimes.put(impl.name, rounds);
        }

        class Stat {
            String name;
            long medianNs;
            double perOpNs;
        }
        List<Stat> stats = new ArrayList<>();
        for (Map.Entry<String, long[]> e : implTimes.entrySet()) {
            long median = median(e.getValue());
            double perOp = median / (double) opsPerRound;
            Stat st = new Stat();
            st.name = e.getKey();
            st.medianNs = median;
            st.perOpNs = perOp;
            stats.add(st);
        }
        stats.sort(comparingLong(s -> s.medianNs));

        long fastest = stats.getFirst().medianNs;

        println("\n===== Benchmark FindTheDifference =====");
        println("Config: warmup=" + warmupRounds + ", measure=" + measureRounds +
                ", casos=" + opsPerRound + " (seed=" + seed + ")");
        println("Clock: System.nanoTime() (monotônico; use deltas).");
        println("---------------------------------------");
        printf("%-12s %14s %14s %14s %12s%n",
                "Implementação", "Mediana(ns)", "Mediana(ms)", "ns/op (med)", "Relativo");
        for (Stat s : stats) {
            double ms = s.medianNs / 1_000_000.0;
            double rel = s.medianNs / (double) fastest;
            printf("%-12s %14d %14.3f %14.2f %12.3f%n",
                    s.name, s.medianNs, ms, s.perOpNs, rel);
        }

        println("\nLegenda:");
        println("• Mediana(ns): tempo mediano por round (todos os casos).");
        println("• ns/op (med): mediana dividida pelo nº de casos (estimativa por operação).");
        println("• Relativo: (tempo_impl / tempo_da_mais_rápida).");
    }

    private static String[] makeCase(Random rnd, int sLen) {
        char[] s = new char[sLen];
        for (int i = 0; i < sLen; i++) s[i] = (char) ('a' + rnd.nextInt(26));
        char extra = (char) ('a' + rnd.nextInt(26));
        int pos = rnd.nextInt(sLen + 1);
        String sStr = new String(s);
        StringBuilder t = new StringBuilder(sLen + 1);
        t.append(s, 0, pos).append(extra);
        if (pos < sLen) t.append(s, pos, sLen - pos);
        return new String[]{sStr, t.toString()};
    }

    private static long median(long[] arr) {
        long[] copy = copyOf(arr, arr.length);
        sort(copy);
        int mid = copy.length / 2;
        return (copy.length % 2 == 0) ? (copy[mid - 1] + copy[mid]) / 2 : copy[mid];
    }
}